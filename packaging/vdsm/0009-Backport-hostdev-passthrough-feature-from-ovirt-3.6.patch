From 02ee5671d3f09f0ebdd61c36efd53490cd5466b7 Mon Sep 17 00:00:00 2001
From: walteryang <walteryang47@users.noreply.github.com>
Date: Tue, 28 Jul 2015 17:31:47 +0800
Subject: [PATCH] Backport hostdev passthrough feature from ovirt-3.6

Signed-off-by: walteryang <walteryang47@users.noreply.github.com>
---
 vdsm.spec.in                 |   2 +
 vdsm/Makefile.am             |   1 +
 vdsm/caps.py                 |   9 +
 vdsm/hostdev.py              |  65 +++++-
 vdsm/rpc/vdsmapi-schema.json |  53 ++++-
 vdsm/supervdsmServer         |  62 +++++-
 vdsm/virt/Makefile.am        |   1 +
 vdsm/virt/vm.py              | 220 +++++++++++++++++++-
 vdsm/virt/vmxml.py           | 485 +++++++++++++++++++++++++++++++++++++++++++
 9 files changed, 886 insertions(+), 12 deletions(-)
 create mode 100644 vdsm/virt/vmxml.py

diff --git a/vdsm.spec.in b/vdsm.spec.in
index a931f6e..2e71323 100644
--- a/vdsm.spec.in
+++ b/vdsm.spec.in
@@ -960,6 +960,7 @@ exit 0
 %{_datadir}/%{vdsm_name}/hooking.py*
 %{_datadir}/%{vdsm_name}/hooks.py*
 %{_datadir}/%{vdsm_name}/hostusb.py*
+%{_datadir}/%{vdsm_name}/hostdev.py*
 %{_datadir}/%{vdsm_name}/lsblk.py*
 %{_datadir}/%{vdsm_name}/md_utils.py*
 %{_datadir}/%{vdsm_name}/mk_sysprep_floppy
@@ -981,6 +982,7 @@ exit 0
 %{_datadir}/%{vdsm_name}/virt/vm.py*
 %{_datadir}/%{vdsm_name}/virt/vmexitreason.py*
 %{_datadir}/%{vdsm_name}/virt/vmpowerdown.py*
+%{_datadir}/%{vdsm_name}/virt/vmxml.py*
 %{_datadir}/%{vdsm_name}/virt/sampling.py*
 %{_datadir}/%{vdsm_name}/tool
 
diff --git a/vdsm/Makefile.am b/vdsm/Makefile.am
index 754f294..28ec8a5 100644
--- a/vdsm/Makefile.am
+++ b/vdsm/Makefile.am
@@ -32,6 +32,7 @@ dist_vdsm_PYTHON = \
 	dmidecodeUtil.py \
 	hooking.py \
 	hooks.py \
+	hostdev.py \
 	hostusb.py \
 	kaxmlrpclib.py \
 	ksm.py \
diff --git a/vdsm/caps.py b/vdsm/caps.py
index 2334b6f..3e95bd7 100644
--- a/vdsm/caps.py
+++ b/vdsm/caps.py
@@ -571,6 +571,14 @@ def _getSELinux():
     return selinux
 
 
+def _getHostdevPassthorughSupport():
+    try:
+        return (bool(len(os.listdir('/sys/class/iommu'))) and
+                bool(len(os.listdir('/sys/kernel/iommu_groups'))))
+    except OSError:
+        return False
+
+
 def get():
     targetArch = getTargetArch()
 
@@ -660,6 +668,7 @@ def get():
         caps['liveSnapshot'] = str(liveSnapSupported).lower()
     caps['liveMerge'] = str(getLiveMergeSupport()).lower()
     caps['kdumpStatus'] = _getKdumpStatus()
+    caps['hostdevPassthrough'] = str(_getHostdevPassthorughSupport()).lower()
 
     return caps
 
diff --git a/vdsm/hostdev.py b/vdsm/hostdev.py
index c59f2ff..140044a 100644
--- a/vdsm/hostdev.py
+++ b/vdsm/hostdev.py
@@ -20,10 +20,17 @@
 
 import xml.etree.ElementTree as etree
 
-import hooks
 from vdsm import libvirtconnection
 import supervdsm
 
+CAPABILITY_TO_XML_ATTR = {'pci': 'pci',
+                          'scsi': 'scsi',
+                          'usb_device': 'usb'}
+
+
+class NoIOMMUSupportException(Exception):
+    pass
+
 
 def _parse_address(caps, children):
     params = {}
@@ -41,8 +48,24 @@ def _parse_usb_address(caps):
     return _parse_address(caps, ('bus', 'device'))
 
 
+def _parse_scsi_address(caps):
+    return _parse_address(caps, ('host', 'bus', 'target', 'lun'))
+
+
 def name_to_pci_path(device_name):
-     return device_name[4:].replace('_', '.').replace('.', ':', 2)
+    return device_name[4:].replace('_', '.').replace('.', ':', 2)
+
+
+def pci_address_to_name(domain, bus, slot, function):
+    """
+    Convert 4 attributes that identify the pci device on the bus to
+    libvirt's pci name: pci_${domain}_${bus}_${slot}_${function}.
+    The first 2 characters are hex notation that is unwanted in the name.
+    """
+    return 'pci_{0}_{1}_{2}_{3}'.format(domain[2:],
+                                        bus[2:],
+                                        slot[2:],
+                                        function[2:])
 
 
 def _sriov_totalvfs(device_name):
@@ -57,6 +80,7 @@ def _parse_device_params(device_xml):
     also doing sysfs lookups for sr-iov related information
     """
     address_parser = {'pci': _parse_pci_address,
+                      'scsi': _parse_scsi_address,
                       'usb_device': _parse_usb_address}
 
     params = {}
@@ -132,3 +156,40 @@ def list_by_caps(caps=None):
         devices[devName] = {'params': params}
 
     return devices
+
+
+def _get_device_ref_and_params(device_name):
+    libvirt_device = libvirtconnection.get().\
+        nodeDeviceLookupByName(device_name)
+    return libvirt_device, _parse_device_params(libvirt_device.XMLDesc(0))
+
+
+def get_device_params(device_name):
+    _, device_params = _get_device_ref_and_params(device_name)
+    return device_params
+
+
+def detach_detachable(device_name):
+    libvirt_device, device_params = _get_device_ref_and_params(device_name)
+
+    if CAPABILITY_TO_XML_ATTR[device_params['capability']] == 'pci':
+        try:
+            iommu_group = device_params['iommu_group']
+        except KeyError:
+            raise NoIOMMUSupportException('hostdev passthrough without iommu')
+        supervdsm.getProxy().appropriateIommuGroup(iommu_group)
+        libvirt_device.detachFlags(None)
+
+    return device_params
+
+
+def reattach_detachable(device_name):
+    libvirt_device, device_params = _get_device_ref_and_params(device_name)
+
+    if CAPABILITY_TO_XML_ATTR[device_params['capability']] == 'pci':
+        try:
+            iommu_group = device_params['iommu_group']
+        except KeyError:
+            raise NoIOMMUSupportException
+        supervdsm.getProxy().rmAppropriateIommuGroup(iommu_group)
+        libvirt_device.reAttach()
diff --git a/vdsm/rpc/vdsmapi-schema.json b/vdsm/rpc/vdsmapi-schema.json
index 5faa8c6..51329c7 100644
--- a/vdsm/rpc/vdsmapi-schema.json
+++ b/vdsm/rpc/vdsmapi-schema.json
@@ -2195,11 +2195,14 @@
 # @graphics:    The graphics device
 #               (new in version 4.15.0)
 #
+# @hostdev:     A host device
+#               (new in version 4.17.0)
+#
 # Since: 4.10.0
 ##
 {'enum': 'VmDeviceType',
  'data': ['disk', 'interface', 'video', 'sound', 'controller', 'balloon',
-          'channel', 'console', 'smartcard', 'rng', 'graphics']}
+          'channel', 'console', 'smartcard', 'rng', 'graphics', 'hostdev']}
 
 ##
 # @VmDiskDeviceType:
@@ -3233,6 +3236,52 @@
  'data': {'deviceType': 'VmDeviceType', 'deviceId': 'UUID'}}
 
 ##
+# @VmHostDeviceSpecParams:
+#
+# Additional VM host device parameters.
+#
+# @iommuPlaceholder:       Flag identifying that the device should not be
+#                          passed through, but needs to be detached and
+#                          reattached in order not to violate IOMMU group
+#                          restrictions.
+#
+# Since: 4.17.0
+##
+{'type': 'VmHostDeviceSpecParams',
+ 'data': {'iommuPlaceholder': 'bool'}}
+
+##
+# @VmHostDevice:
+#
+# Properties of a VM host device.
+#
+# @deviceType:  The device type (always @hostdev)
+#
+# @deviceId:    A unique ID for this device
+#
+# @device:      Libvirt identifier of the device
+#               (such as pci_0000_10_0_1)
+#
+# @bootOrder:   #optional If specified, this device is part of the boot
+#               sequence at the specified position
+#
+# @address:     #optional Device hardware address as seen from the
+#               guest. If not specified, this field will be populated
+#               by libvirt generated address.
+#
+# @alias:       Alias used to identify this device in commands
+#
+# @specParams:  #optional Additional device parameters
+#
+# Since: 4.17.0
+##
+{'type': 'VmHostDevice',
+ 'data': {'deviceType': 'VmDeviceType', 'deviceId': 'UUID',
+          'device': 'str', 'bootOrder': 'int',
+          'address': 'VmDeviceAddress', 'alias': 'str',
+          '*specParams': 'VmHostDeviceSpecParams'}}
+
+##
 # @VmDevice:
 #
 # A discriminated record containing VM device properties.
@@ -3246,7 +3295,7 @@
  'union': ['VmDiskDevice', 'VmInterfaceDevice', 'VmVideoDevice',
           'VmSoundDevice', 'VmControllerDevice', 'VmBalloonDevice',
           'VmChannelDevice', 'VmWatchdogDevice', 'VmConsoleDevice',
-          'VmSmartcardDevice', 'VmGraphicsDevice']}
+          'VmSmartcardDevice', 'VmGraphicsDevice', 'VmHostDevice']}
 
 ##
 # @VmShortStatus:
diff --git a/vdsm/supervdsmServer b/vdsm/supervdsmServer
index a63caa2..c8b220b 100755
--- a/vdsm/supervdsmServer
+++ b/vdsm/supervdsmServer
@@ -69,8 +69,9 @@ from storage.iscsi import readSessionInfo as _readSessionInfo
 from supervdsm import _SuperVdsmManager
 from storage.fileUtils import chown, resolveGid, resolveUid
 from storage.fileUtils import validateAccess as _validateAccess
-from vdsm.constants import METADATA_GROUP, EXT_UDEVADM, \
-    DISKIMAGE_USER, DISKIMAGE_GROUP, P_LIBVIRT_VMCHANNELS, VDSM_USER
+from vdsm.constants import METADATA_GROUP, EXT_CHOWN, EXT_UDEVADM, \
+    DISKIMAGE_USER, DISKIMAGE_GROUP, P_LIBVIRT_VMCHANNELS, VDSM_USER, \
+    QEMU_PROCESS_USER, QEMU_PROCESS_GROUP
 from storage.devicemapper import _removeMapping, _getPathsStatus
 from vdsm.config import config
 import ksm
@@ -82,6 +83,9 @@ _UDEV_RULE_FILE_PREFIX = "99-vdsm-"
 _UDEV_RULE_FILE_EXT = ".rules"
 _UDEV_RULE_FILE_NAME = _UDEV_RULE_FILE_DIR + _UDEV_RULE_FILE_PREFIX + \
     "%s-%s" + _UDEV_RULE_FILE_EXT
+_UDEV_RULE_FILE_NAME_VFIO = os.path.join(
+    _UDEV_RULE_FILE_DIR, _UDEV_RULE_FILE_PREFIX + "iommu_group_%s" +
+    _UDEV_RULE_FILE_EXT)
 
 RUN_AS_TIMEOUT = config.getint("irs", "process_pool_timeout")
 
@@ -312,6 +316,60 @@ class _SuperVdsm(object):
         return fails
 
     @logDecorator
+    def appropriateIommuGroup(self, iommu_group):
+        """
+        Create udev rule in /etc/udev/rules.d/ to change ownership
+        of /dev/vfio/$iommu_group to qemu:qemu. This method should be called
+        when detaching a device from the host.
+        """
+        rule_file = _UDEV_RULE_FILE_NAME_VFIO % iommu_group
+
+        if not os.path.isfile(rule_file):
+            # If the file exists, different device from the same group has
+            # already been detached and we therefore can skip overwriting the
+            # file. Also, this file should only be created/removed via the
+            # means of supervdsm.
+
+            rule = ('KERNEL=="{}", SUBSYSTEM=="vfio" RUN+="{} {}:{} '
+                    '/dev/vfio/{}"').format(iommu_group, EXT_CHOWN,
+                                            QEMU_PROCESS_USER,
+                                            QEMU_PROCESS_GROUP,
+                                            iommu_group)
+
+            with open(rule_file, "w") as rf:
+                self.log.debug("Creating rule %s: %r", rule_file, rule)
+                rf.write(rule)
+
+            self.udevTrigger(iommu_group)
+
+    @logDecorator
+    def rmAppropriateIommuGroup(self, iommu_group):
+        """
+        Remove udev rule in /etc/udev/rules.d/ created by
+        vfioAppropriateDevice.
+        """
+        rule_file = os.path.join(_UDEV_RULE_FILE_DIR, _UDEV_RULE_FILE_PREFIX +
+                                 "iommu_group_" + iommu_group +
+                                 _UDEV_RULE_FILE_EXT)
+        error = False
+
+        try:
+            os.remove(rule_file)
+        except OSError as e:
+            if e.errno == errno.ENOENT:
+                # OSError with ENOENT errno here means that the rule file does
+                # not exist - this is expected when multiple devices in one
+                # iommu group were passed through.
+                error = True
+            else:
+                raise
+        else:
+            self.log.debug("Removing rule %s", rule_file)
+
+        if not error:
+            self.udevTrigger(iommu_group)
+
+    @logDecorator
     def ksmTune(self, tuningParams):
         '''
         Set KSM tuning parameters for MOM, which runs without root privilege
diff --git a/vdsm/virt/Makefile.am b/vdsm/virt/Makefile.am
index 8965c77..cc2ca54 100644
--- a/vdsm/virt/Makefile.am
+++ b/vdsm/virt/Makefile.am
@@ -31,6 +31,7 @@ dist_vdsm_virt_PYTHON = \
 	vmexitreason.py \
 	vmpowerdown.py \
 	vmstatus.py \
+	vmxml.py \
 	$(NULL)
 
 EXTRA_DIST = \
diff --git a/vdsm/virt/vm.py b/vdsm/virt/vm.py
index 71ae3b7..79aa5df 100644
--- a/vdsm/virt/vm.py
+++ b/vdsm/virt/vm.py
@@ -56,15 +56,19 @@ from storage import fileUtils
 from logUtils import SimpleLogAdapter
 import caps
 import hooks
+import hostdev
 import supervdsm
 import numaUtils
 
 # local package imports
+from hostdev import get_device_params, detach_detachable, \
+    CAPABILITY_TO_XML_ATTR
 from . import guestagent
 from . import migration
 from . import sampling
 from . import vmexitreason
 from . import vmstatus
+from . import vmxml
 
 from vmpowerdown import VmShutdown, VmReboot
 
@@ -90,6 +94,8 @@ WATCHDOG_DEVICES = 'watchdog'
 CONSOLE_DEVICES = 'console'
 SMARTCARD_DEVICES = 'smartcard'
 TPM_DEVICES = 'tpm'
+HOSTDEV = 'hostdev'
+NIC = 'interface'
 
 METADATA_VM_TUNE_URI = 'http://ovirt.org/vm/tune/1.0'
 
@@ -1831,6 +1837,136 @@ class HostUSBDevice(VmDevice):
         return m
 
 
+class Base(vmxml.Device):
+    __slots__ = ('deviceType', 'device', 'alias', 'specParams', 'deviceId',
+                 'conf', 'log', '_deviceXML', 'type', 'custom')
+
+    def __init__(self, conf, log, **kwargs):
+        self.conf = conf
+        self.log = log
+        self.specParams = {}
+        self.custom = kwargs.pop('custom', {})
+        for attr, value in kwargs.iteritems():
+            try:
+                setattr(self, attr, value)
+            except AttributeError:  # skip read-only properties
+                self.log.debug('Ignoring param (%s, %s) in %s', attr, value,
+                               self.__class__.__name__)
+        self._deviceXML = None
+
+    def __str__(self):
+        attrs = [':'.join((a, str(getattr(self, a, None)))) for a in dir(self)
+                 if not a.startswith('__')]
+        return ' '.join(attrs)
+
+
+class SkipDevice(Exception):
+    pass
+
+
+class HostDevice(Base):
+    __slots__ = ('address', 'hostAddress', 'bootOrder', '_deviceParams',
+                 'macAddr', 'vlanId')
+
+    def __init__(self, conf, log, **kwargs):
+        super(HostDevice, self).__init__(conf, log, **kwargs)
+
+        self._deviceParams = get_device_params(self.device)
+
+        self.macAddr = self.specParams.get('macAddr')
+        self.vlanId = self.specParams.get('vlanId')
+        self.hostAddress = self._deviceParams.get('address')
+
+    def detach(self):
+        """
+        Detach the device from the host. This method *must* be
+        called before getXML in order to populate _deviceParams.
+        """
+        self._deviceParams = detach_detachable(self.device)
+
+    def getXML(self):
+        if any((self.macAddr, self.vlanId)):
+            xml = self._create_network_interface_xml()
+        else:
+            xml = self._create_generic_hostdev_xml()
+            return xml
+
+        if hasattr(self, 'bootOrder'):
+            xml.appendChildWithArgs('boot', order=self.bootOrder)
+
+        if hasattr(self, 'address'):
+            self._add_source_address(xml)
+
+        return xml
+
+    def _create_generic_hostdev_xml(self):
+        """
+            Create domxml for a host device.
+
+            <devices>
+                <hostdev mode='subsystem' type='pci' managed='no'>
+                <source>
+                    <address domain='0x0000' bus='0x06' slot='0x02'
+                    function='0x0'/>
+                </source>
+                <boot order='1'/>
+                </hostdev>
+            </devices>
+            """
+
+        if (CAPABILITY_TO_XML_ATTR[
+                self._deviceParams['capability']] == 'pci' and
+                utils.tobool(self.specParams.get('iommuPlaceholder', False))):
+            raise SkipDevice
+
+        hostdevice = self.createXmlElem(HOSTDEV, None)
+        hostdevice.setAttrs(
+            managed='no', mode='subsystem',
+            type=CAPABILITY_TO_XML_ATTR[self._deviceParams['capability']])
+        source = hostdevice.appendChildWithArgs('source')
+
+        self._add_source_address(source)
+
+        return hostdevice
+
+    def _create_network_interface_xml(self):
+        """
+        Create domxml for a host device.
+
+        <devices>
+         <interface type='hostdev' managed='no'>
+          <driver name='vfio'/>
+          <source>
+           <address type='pci' domain='0x0000' bus='0x00' slot='0x07'
+           function='0x0'/>
+          </source>
+          <mac address='52:54:00:6d:90:02'/>
+          <vlan>
+           <tag id=100/>
+          </vlan>
+          <boot order='1'/>
+         </interface>
+        </devices>
+        """
+        interface = self.createXmlElem(NIC, HOSTDEV)
+        interface.setAttrs(managed='no')
+        interface.appendChildWithArgs('driver', name='vfio')
+        source = interface.appendChildWithArgs('source')
+        self._add_source_address(source, type='pci')
+
+        if self.macAddr is not None:
+            interface.appendChildWithArgs('mac', address=self.macAddr)
+        if self.vlanId is not None:
+            vlan = interface.appendChildWithArgs('vlan')
+            vlan.appendChildWithArgs('tag', id=str(self.vlanId))
+
+        return interface
+
+    def _add_source_address(self, parent_element, type=None):
+        parent_element.appendChildWithArgs('address', type=type,
+                                           **self._deviceParams['address'])
+
+
 class MigrationError(Exception):
     pass
 
@@ -1870,7 +2006,8 @@ class Vm(object):
                      (REDIR_DEVICES, RedirDevice),
                      (RNG_DEVICES, RngDevice),
                      (SMARTCARD_DEVICES, SmartCardDevice),
-                     (TPM_DEVICES, TpmDevice))
+                     (TPM_DEVICES, TpmDevice),
+                     (HOSTDEV, HostDevice))
 
     def _makeDeviceDict(self):
         return dict((dev, []) for dev, _ in self.DeviceMapping)
@@ -2840,6 +2977,16 @@ class Vm(object):
 
         self._guestSockCleanup(self._guestSocketFile)
 
+    def _reattachHostDevices(self):
+        # reattach host devices
+        for dev in self._devices[HOSTDEV]:
+            self.log.debug('Reattaching device %s to host.' % dev.device)
+            try:
+                hostdev.reattach_detachable(dev.device)
+            except hostdev.NoIOMMUSupportException:
+                self.log.exception('Could not reattach device %s back to host '
+                                   'due to missing IOMMU support.')
+
     def setDownStatus(self, code, exitReasonCode, exitMessage=''):
         if not exitMessage:
             exitMessage = vmexitreason.exitReasons.get(exitReasonCode,
@@ -3099,7 +3246,11 @@ class Vm(object):
 
         for devType in self._devices:
             for dev in self._devices[devType]:
-                deviceXML = dev.getXML().toxml(encoding='utf-8')
+                try:
+                    deviceXML = dev.getXML().toxml(encoding='utf-8')
+                except SkipDevice:
+                    self.log.info('Skipping device %s.', dev.device)
+                    continue
 
                 if getattr(dev, "custom", {}):
                     deviceXML = hooks.before_device_create(
@@ -3185,6 +3336,7 @@ class Vm(object):
         self._cleanupGuestAgent()
         utils.rmFile(self._recoveryFile)
         self._guestSockCleanup(self._qemuguestSocketFile)
+        self._reattachHostDevices()
 
     def _isDomainRunning(self):
         try:
@@ -3212,6 +3364,7 @@ class Vm(object):
         self._getUnderlyingWatchdogDeviceInfo()
         self._getUnderlyingSmartcardDeviceInfo()
         self._getUnderlyingConsoleDeviceInfo()
+        self._getUnderlyingHostDeviceInfo()
         # Obtain info of all unknown devices. Must be last!
         self._getUnderlyingUnknownDeviceInfo()
 
@@ -3349,8 +3502,17 @@ class Vm(object):
         # domDependentInit, after the migration is completed.
 
         if not self.recovering and initDomain:
-            domxml = hooks.before_vm_start(self._buildCmdLine(), self.conf)
-            self.log.debug(domxml)
+            for dev in self._devices[HOSTDEV]:
+                self.log.debug('Detaching device %s from the host.' %
+                               dev.device)
+                dev.detach()
+
+            if initDomain:
+                domxml = hooks.before_vm_start(self._buildCmdLine(),
+                                               self.conf)
+                # TODO: this is debug information. For 3.6.x we still need to
+                # see the XML even with 'info' as default level.
+                self.log.info(domxml)
 
         if self.recovering:
             self._dom = NotifyingVirDomain(
@@ -5079,12 +5241,12 @@ class Vm(object):
         self.log.exception("Operation failed")
         return self._reportError(key, msg)
 
-    def _getUnderlyingDeviceAddress(self, devXml):
+    def _getUnderlyingDeviceAddress(self, devXml, index=0):
         """
         Obtain device's address from libvirt
         """
         address = {}
-        adrXml = devXml.getElementsByTagName('address')[0]
+        adrXml = devXml.getElementsByTagName('address')[index]
         # Parse address to create proper dictionary.
         # Libvirt device's address definition is:
         # PCI = {'type':'pci', 'domain':'0x0000', 'bus':'0x00',
@@ -5248,6 +5410,52 @@ class Vm(object):
                     dev['address'] = address
                     dev['alias'] = alias
 
+    def _getUnderlyingHostDeviceInfo(self):
+        """
+        Obtain host device info from libvirt
+        """
+        hostdevxml = _domParseStr(self._lastXMLDesc).childNodes[0].\
+            getElementsByTagName('devices')[0].\
+            getElementsByTagName('hostdev')
+        for x in hostdevxml:
+            device_type = x.getAttribute('type')
+            if device_type == 'usb':
+                self._getUnderlyingHostDeviceUSBInfo(x)
+                continue
+            alias = x.getElementsByTagName('alias')[0].getAttribute('name')
+            address = self._getUnderlyingDeviceAddress(x)
+            source = x.getElementsByTagName('source')[0]
+            device = hostdev.pci_address_to_name(
+                **self._getUnderlyingDeviceAddress(source))
+
+            # We can assume the device name to be correct since we're
+            # inspecting source element. For the address, we may look at
+            # both addresses and determine the correct one.
+            if (hostdev.pci_address_to_name(**address) == device):
+                address = self._getUnderlyingDeviceAddress(x, 1)
+
+            known_device = False
+            for dev in self.conf['devices']:
+                if dev['device'] == device:
+                    dev['alias'] = alias
+                    dev['address'] = address
+
+            for dev in self._devices[HOSTDEV]:
+                if dev.device == device:
+                    dev.alias = alias
+                    dev.address = address
+                    known_device = True
+
+            if not known_device:
+                device = hostdev.pci_address_to_name(
+                    **self._getUnderlyingDeviceAddress(source))
+
+                hostdevice = {'type': HOSTDEV,
+                              'device': device,
+                              'alias': alias,
+                              'address': address}
+                self.conf['devices'].append(hostdevice)
+
     def _getUnderlyingWatchdogDeviceInfo(self):
         """
         Obtain watchdog device info from libvirt.
diff --git a/vdsm/virt/vmxml.py b/vdsm/virt/vmxml.py
new file mode 100644
index 0000000..38d2200
--- /dev/null
+++ b/vdsm/virt/vmxml.py
@@ -0,0 +1,485 @@
+#
+# Copyright 2008-2014 Red Hat, Inc.
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+#
+# Refer to the README and COPYING files for full details of the license
+#
+
+from operator import itemgetter
+import xml.dom
+import xml.dom.minidom
+import xml.etree.ElementTree as etree
+
+from vdsm import constants
+from vdsm import utils
+
+import caps
+
+
+def has_channel(domXML, name):
+    domObj = etree.fromstring(domXML)
+    devices = domObj.findall('devices')
+
+    if len(devices) == 1:
+        for chan in devices[0].findall('channel'):
+            targets = chan.findall('target')
+            if len(targets) == 1:
+                if targets[0].attrib['name'] == name:
+                    return True
+
+    return False
+
+
+def all_devices(domXML):
+    domObj = xml.dom.minidom.parseString(domXML)
+    devices = domObj.childNodes[0].getElementsByTagName('devices')[0]
+
+    for deviceXML in devices.childNodes:
+        if deviceXML.nodeType == xml.dom.Node.ELEMENT_NODE:
+            yield deviceXML
+
+
+def filter_devices_with_alias(devices):
+    for deviceXML in devices:
+        aliasElement = deviceXML.getElementsByTagName('alias')
+        if aliasElement:
+            alias = aliasElement[0].getAttribute('name')
+            yield deviceXML, alias
+
+
+class Device(object):
+    # since we're inheriting all VM devices from this class, __slots__ must
+    # be initialized here in order to avoid __dict__ creation
+    __slots__ = ()
+
+    def createXmlElem(self, elemType, deviceType, attributes=()):
+        """
+        Create domxml device element according to passed in params
+        """
+        elemAttrs = {}
+        element = Element(elemType)
+
+        if deviceType:
+            elemAttrs['type'] = deviceType
+
+        for attrName in attributes:
+            if not hasattr(self, attrName):
+                continue
+
+            attr = getattr(self, attrName)
+            if isinstance(attr, dict):
+                element.appendChildWithArgs(attrName, **attr)
+            else:
+                elemAttrs[attrName] = attr
+
+        element.setAttrs(**elemAttrs)
+        return element
+
+
+class Element(object):
+
+    def __init__(self, tagName, text=None, **attrs):
+        self._elem = xml.dom.minidom.Document().createElement(tagName)
+        self.setAttrs(**attrs)
+        if text is not None:
+            self.appendTextNode(text)
+
+    def __getattr__(self, name):
+        return getattr(self._elem, name)
+
+    def setAttrs(self, **attrs):
+        for attrName, attrValue in attrs.iteritems():
+            self._elem.setAttribute(attrName, attrValue)
+
+    def appendTextNode(self, text):
+        textNode = xml.dom.minidom.Document().createTextNode(text)
+        self._elem.appendChild(textNode)
+
+    def appendChild(self, element):
+        self._elem.appendChild(element)
+
+    def appendChildWithArgs(self, childName, text=None, **attrs):
+        child = Element(childName, text, **attrs)
+        self._elem.appendChild(child)
+        return child
+
+
+class Domain(object):
+
+    def __init__(self, conf, log, arch):
+        """
+        Create the skeleton of a libvirt domain xml
+
+        <domain type="kvm">
+            <name>vmName</name>
+            <uuid>9ffe28b6-6134-4b1e-8804-1185f49c436f</uuid>
+            <memory>262144</memory>
+            <currentMemory>262144</currentMemory>
+            <vcpu current='smp'>160</vcpu>
+            <devices>
+            </devices>
+        </domain>
+
+        """
+        self.conf = conf
+        self.log = log
+
+        self.arch = arch
+
+        self.doc = xml.dom.minidom.Document()
+
+        if utils.tobool(self.conf.get('kvmEnable', 'true')):
+            domainType = 'kvm'
+        else:
+            domainType = 'qemu'
+
+        domainAttrs = {'type': domainType}
+
+        # Hack around libvirt issue BZ#988070, this is going to be removed as
+        # soon as the domain XML format supports the specification of USB
+        # keyboards
+
+        if self.arch == caps.Architecture.PPC64:
+            domainAttrs['xmlns:qemu'] = \
+                'http://libvirt.org/schemas/domain/qemu/1.0'
+
+        self.dom = Element('domain', **domainAttrs)
+        self.doc.appendChild(self.dom)
+
+        self.dom.appendChildWithArgs('name', text=self.conf['vmName'])
+        self.dom.appendChildWithArgs('uuid', text=self.conf['vmId'])
+        if 'numOfIoThreads' in self.conf:
+            self.dom.appendChildWithArgs('iothreads',
+                                         text=str(self.conf['numOfIoThreads']))
+        memSizeKB = str(int(self.conf.get('memSize', '256')) * 1024)
+        self.dom.appendChildWithArgs('memory', text=memSizeKB)
+        self.dom.appendChildWithArgs('currentMemory', text=memSizeKB)
+        if 'maxMemSize' in self.conf:
+            maxMemSizeKB = str(int(self.conf['maxMemSize']) * 1024)
+            maxMemSlots = str(self.conf.get('maxMemSlots', '16'))
+            self.dom.appendChildWithArgs('maxMemory', text=maxMemSizeKB,
+                                         slots=maxMemSlots)
+        vcpu = self.dom.appendChildWithArgs('vcpu', text=self._getMaxVCpus())
+        vcpu.setAttrs(**{'current': self._getSmp()})
+
+        self._devices = Element('devices')
+        self.dom.appendChild(self._devices)
+
+    def appendClock(self):
+        """
+        Add <clock> element to domain:
+
+        <clock offset="variable" adjustment="-3600">
+            <timer name="rtc" tickpolicy="catchup">
+        </clock>
+
+        for hyperv:
+        <clock offset="variable" adjustment="-3600">
+            <timer name="hypervclock">
+        </clock>
+        """
+
+        m = Element('clock', offset='variable',
+                    adjustment=str(self.conf.get('timeOffset', 0)))
+        if utils.tobool(self.conf.get('hypervEnable', 'false')):
+            m.appendChildWithArgs('timer', name='hypervclock')
+        else:
+            m.appendChildWithArgs('timer', name='rtc', tickpolicy='catchup')
+        m.appendChildWithArgs('timer', name='pit', tickpolicy='delay')
+
+        if self.arch == caps.Architecture.X86_64:
+            m.appendChildWithArgs('timer', name='hpet', present='no')
+
+        self.dom.appendChild(m)
+
+    def appendOs(self):
+        """
+        Add <os> element to domain:
+
+        <os>
+            <type arch="x86_64" machine="pc">hvm</type>
+            <boot dev="cdrom"/>
+            <kernel>/tmp/vmlinuz-2.6.18</kernel>
+            <initrd>/tmp/initrd-2.6.18.img</initrd>
+            <cmdline>ARGs 1</cmdline>
+            <smbios mode="sysinfo"/>
+        </os>
+        """
+
+        oselem = Element('os')
+        self.dom.appendChild(oselem)
+
+        DEFAULT_MACHINES = {caps.Architecture.X86_64: 'pc',
+                            caps.Architecture.PPC64: 'pseries',
+                            caps.Architecture.PPC64LE: 'pseries'}
+
+        machine = self.conf.get('emulatedMachine', DEFAULT_MACHINES[self.arch])
+
+        oselem.appendChildWithArgs('type', text='hvm', arch=self.arch,
+                                   machine=machine)
+
+        qemu2libvirtBoot = {'a': 'fd', 'c': 'hd', 'd': 'cdrom', 'n': 'network'}
+        for c in self.conf.get('boot', ''):
+            oselem.appendChildWithArgs('boot', dev=qemu2libvirtBoot[c])
+
+        if self.conf.get('initrd'):
+            oselem.appendChildWithArgs('initrd', text=self.conf['initrd'])
+
+        if self.conf.get('kernel'):
+            oselem.appendChildWithArgs('kernel', text=self.conf['kernel'])
+
+        if self.conf.get('kernelArgs'):
+            oselem.appendChildWithArgs('cmdline', text=self.conf['kernelArgs'])
+
+        if self.arch == caps.Architecture.X86_64:
+            oselem.appendChildWithArgs('smbios', mode='sysinfo')
+
+        if utils.tobool(self.conf.get('bootMenuEnable', False)):
+            oselem.appendChildWithArgs('bootmenu', enable='yes')
+
+    def appendSysinfo(self, osname, osversion, serialNumber):
+        """
+        Add <sysinfo> element to domain:
+
+        <sysinfo type="smbios">
+          <bios>
+            <entry name="vendor">QEmu/KVM</entry>
+            <entry name="version">0.13</entry>
+          </bios>
+          <system>
+            <entry name="manufacturer">Fedora</entry>
+            <entry name="product">Virt-Manager</entry>
+            <entry name="version">0.8.2-3.fc14</entry>
+            <entry name="serial">32dfcb37-5af1-552b-357c-be8c3aa38310</entry>
+            <entry name="uuid">c7a5fdbd-edaf-9455-926a-d65c16db1809</entry>
+          </system>
+        </sysinfo>
+        """
+
+        sysinfoelem = Element('sysinfo', type='smbios')
+        self.dom.appendChild(sysinfoelem)
+
+        syselem = Element('system')
+        sysinfoelem.appendChild(syselem)
+
+        def appendEntry(k, v):
+            syselem.appendChildWithArgs('entry', text=v, name=k)
+
+        appendEntry('manufacturer', constants.SMBIOS_MANUFACTURER)
+        appendEntry('product', osname)
+        appendEntry('version', osversion)
+        appendEntry('serial', serialNumber)
+        appendEntry('uuid', self.conf['vmId'])
+
+    def appendFeatures(self):
+        """
+        Add machine features to domain xml.
+
+        Currently only
+        <features>
+            <acpi/>
+        <features/>
+
+        for hyperv:
+        <features>
+            <acpi/>
+            <hyperv>
+                <relaxed state='on'/>
+            </hyperv>
+        <features/>
+        """
+
+        if (utils.tobool(self.conf.get('acpiEnable', 'true')) or
+           utils.tobool(self.conf.get('hypervEnable', 'false'))):
+            features = self.dom.appendChildWithArgs('features')
+
+        if utils.tobool(self.conf.get('acpiEnable', 'true')):
+            features.appendChildWithArgs('acpi')
+
+        if utils.tobool(self.conf.get('hypervEnable', 'false')):
+            hyperv = Element('hyperv')
+            features.appendChild(hyperv)
+
+            hyperv.appendChildWithArgs('relaxed', state='on')
+            # turns off an internal Windows watchdog, and by doing so avoids
+            # some high load BSODs.
+            hyperv.appendChildWithArgs('vapic', state='on')
+            # magic number taken from recomendations. References:
+            # https://bugzilla.redhat.com/show_bug.cgi?id=1083529#c10
+            # https://bugzilla.redhat.com/show_bug.cgi?id=1053846#c0
+            hyperv.appendChildWithArgs(
+                'spinlocks', state='on', retries='8191')
+
+    def appendCpu(self):
+        """
+        Add guest CPU definition.
+
+        <cpu match="exact">
+            <model>qemu64</model>
+            <topology sockets="S" cores="C" threads="T"/>
+            <feature policy="require" name="sse2"/>
+            <feature policy="disable" name="svm"/>
+        </cpu>
+        """
+
+        cpu = Element('cpu')
+
+        if self.arch in (caps.Architecture.X86_64):
+            cpu.setAttrs(match='exact')
+
+            features = self.conf.get('cpuType', 'qemu64').split(',')
+            model = features[0]
+
+            if model == 'hostPassthrough':
+                cpu.setAttrs(mode='host-passthrough')
+            elif model == 'hostModel':
+                cpu.setAttrs(mode='host-model')
+            else:
+                cpu.appendChildWithArgs('model', text=model)
+
+                # This hack is for backward compatibility as the libvirt
+                # does not allow 'qemu64' guest on intel hardware
+                if model == 'qemu64' and '+svm' not in features:
+                    features += ['-svm']
+
+                for feature in features[1:]:
+                    # convert Linux name of feature to libvirt
+                    if feature[1:6] == 'sse4_':
+                        feature = feature[0] + 'sse4.' + feature[6:]
+
+                    featureAttrs = {'name': feature[1:]}
+                    if feature[0] == '+':
+                        featureAttrs['policy'] = 'require'
+                    elif feature[0] == '-':
+                        featureAttrs['policy'] = 'disable'
+                    cpu.appendChildWithArgs('feature', **featureAttrs)
+
+        if ('smpCoresPerSocket' in self.conf or
+                'smpThreadsPerCore' in self.conf):
+            maxVCpus = int(self._getMaxVCpus())
+            cores = int(self.conf.get('smpCoresPerSocket', '1'))
+            threads = int(self.conf.get('smpThreadsPerCore', '1'))
+            cpu.appendChildWithArgs('topology',
+                                    sockets=str(maxVCpus / cores / threads),
+                                    cores=str(cores), threads=str(threads))
+
+        # CPU-pinning support
+        # see http://www.ovirt.org/wiki/Features/Design/cpu-pinning
+        if 'cpuPinning' in self.conf:
+            cputune = Element('cputune')
+            cpuPinning = self.conf.get('cpuPinning')
+            for cpuPin in cpuPinning.keys():
+                cputune.appendChildWithArgs('vcpupin', vcpu=cpuPin,
+                                            cpuset=cpuPinning[cpuPin])
+            self.dom.appendChild(cputune)
+
+        # Guest numa topology support
+        # see http://www.ovirt.org/Features/NUMA_and_Virtual_NUMA
+        if 'guestNumaNodes' in self.conf:
+            numa = Element('numa')
+            guestNumaNodes = sorted(
+                self.conf.get('guestNumaNodes'), key=itemgetter('nodeIndex'))
+            for vmCell in guestNumaNodes:
+                nodeMem = int(vmCell['memory']) * 1024
+                numa.appendChildWithArgs('cell',
+                                         cpus=vmCell['cpus'],
+                                         memory=str(nodeMem))
+            cpu.appendChild(numa)
+
+        self.dom.appendChild(cpu)
+
+    # Guest numatune support
+    def appendNumaTune(self):
+        """
+        Add guest numatune definition.
+
+        <numatune>
+            <memory mode='strict' nodeset='0-1'/>
+        </numatune>
+        """
+
+        if 'numaTune' in self.conf:
+            numaTune = self.conf.get('numaTune')
+            if 'nodeset' in numaTune.keys():
+                mode = numaTune.get('mode', 'strict')
+                numatune = Element('numatune')
+                numatune.appendChildWithArgs('memory', mode=mode,
+                                             nodeset=numaTune['nodeset'])
+                self.dom.appendChild(numatune)
+
+    def _appendAgentDevice(self, path, name):
+        """
+          <channel type='unix'>
+             <target type='virtio' name='org.linux-kvm.port.0'/>
+             <source mode='bind' path='/tmp/socket'/>
+          </channel>
+        """
+        channel = Element('channel', type='unix')
+        channel.appendChildWithArgs('target', type='virtio', name=name)
+        channel.appendChildWithArgs('source', mode='bind', path=path)
+        self._devices.appendChild(channel)
+
+    def appendInput(self):
+        """
+        Add input device.
+
+        <input bus="ps2" type="mouse"/>
+        """
+        if utils.tobool(self.conf.get('tabletEnable')):
+            inputAttrs = {'type': 'tablet', 'bus': 'usb'}
+        else:
+            if self.arch == caps.Architecture.PPC64:
+                mouseBus = 'usb'
+            else:
+                mouseBus = 'ps2'
+
+            inputAttrs = {'type': 'mouse', 'bus': mouseBus}
+        self._devices.appendChildWithArgs('input', **inputAttrs)
+
+    def appendKeyboardDevice(self):
+        """
+        Add keyboard device for ppc64 using a QEMU argument directly.
+        This is a workaround to the issue BZ#988070 in libvirt
+
+            <qemu:commandline>
+                <qemu:arg value='-usbdevice'/>
+                <qemu:arg value='keyboard'/>
+            </qemu:commandline>
+        """
+        commandLine = Element('qemu:commandline')
+        commandLine.appendChildWithArgs('qemu:arg', value='-usbdevice')
+        commandLine.appendChildWithArgs('qemu:arg', value='keyboard')
+        self.dom.appendChild(commandLine)
+
+    def appendEmulator(self):
+        emulatorPath = '/usr/bin/qemu-system-' + self.arch
+
+        emulator = Element('emulator', text=emulatorPath)
+
+        self._devices.appendChild(emulator)
+
+    def appendDeviceXML(self, deviceXML):
+        self._devices.appendChild(
+            xml.dom.minidom.parseString(deviceXML).firstChild)
+
+    def toxml(self):
+        return self.doc.toprettyxml(encoding='utf-8')
+
+    def _getSmp(self):
+        return self.conf.get('smp', '1')
+
+    def _getMaxVCpus(self):
+        return self.conf.get('maxVCpus', self._getSmp())
-- 
1.9.3

